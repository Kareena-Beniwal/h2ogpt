
    """

    :param load_8bit: load model in 8-bit using bitsandbytes
    :param load_4bit: load model in 4-bit using bitsandbytes
    :param low_bit_mode: 0: no quantization config 1: change compute 2: nf4 3: double quant 4: 2 and 3
           See: https://huggingface.co/docs/transformers/main_classes/quantization
           If using older bitsandbytes or transformers, 0 is required
    :param load_half: load model in float16 (None means auto, which means True unless t5 based model)
                      otherwise specify bool
    :param use_flash_attention_2: Whether to try to use flash attention 2 if available when loading HF models
           Warning: We have seen nans and type mismatches with flash-attn==2.3.4 installed and this enabled,
                    even for other models like embedding model that is unrelated to primary models.
    :param load_gptq: to load model with GPTQ, put model_basename here, e.g. 'model' for TheBloke models
    :param use_autogptq: whether to use AutoGPTQ (True) or HF Transformers (False)
           Some models are only supported by one or the other
    :param load_awq: load model with AWQ, e.g. 'model' for TheBloke models
    :param load_exllama: whether to use exllama (only applicable to LLaMa1/2 models with 16-bit or GPTQ
    :param use_safetensors: to use safetensors version (assumes file/HF points to safe tensors version)
    :param revision: Which HF revision to use
    :param use_gpu_id: whether to control devices with gpu_id.  If False, then spread across GPUs
    :param base_model: model HF-type name.  If use --base_model to preload model, cannot unload in gradio in models tab
    :param tokenizer_base_model: tokenizer HF-type name.  Usually not required, inferred from base_model.
           If model is private or doesn't exist as HF model, can use "tiktoken" and pass max_seq_len and (if different) max_output_seq_len
           For inference servers like OpenAI etc. if have model name, we use tiktoken with known input/output sequence lengths.
    :param lora_weights: LORA weights path/HF link
    :param gpu_id: if use_gpu_id, then use gpu_id for cuda device ID, or auto mode if gpu_id != -1
    :param compile_model Whether to compile the model
    :param use_cache: Whether to use caching in model (some models fail when multiple threads use)
    :param inference_server: Consume base_model as type of model at this address
                             Address can be text-generation-server hosting that base_model
                             e.g. python generate.py --inference_server="http://192.168.1.46:6112" --base_model=HuggingFaceH4/zephyr-7b-beta

                             For a gradio server, use same as TGI server.  We infer if it's TGI or Gradio.
                             e.g. python generate.py --inference_server="http://192.168.1.46:7860" --base_model=HuggingFaceH4/zephyr-7b-beta
                             For auth protected gradio, do:
                             e.g. python generate.py --inference_server="http://192.168.1.46:7860:user:password" --base_model=HuggingFaceH4/zephyr-7b-beta
                             If don't want to specify port, do:
                             e.g. python generate.py --inference_server="https://gpt.h2o.ai:None:user:password" --base_model=HuggingFaceH4/zephyr-7b-beta


                             Or Address can be "openai_chat" or "openai" for OpenAI API
                             Or Address can be "openai_azure_chat" or "openai_azure" for Azure OpenAI API
                             e.g. python generate.py --inference_server="openai_chat" --base_model=gpt-3.5-turbo
                             e.g. python generate.py --inference_server="openai" --base_model=text-davinci-003
                             e.g. python generate.py --inference_server="openai_azure_chat:<deployment_name>:<baseurl>:<api_version>:<access key>" --base_model=gpt-3.5-turbo
                             e.g. python generate.py --inference_server="openai_azure:<deployment_name>:<baseurl>:<api_version>:<access key>" --base_model=text-davinci-003
                             Optionals (Replace with None or just leave empty but keep :)
                                 <deployment_name> of some deployment name
                                 <baseurl>: e.g. "<endpoint>.openai.azure.com" for some <endpoint> without https://
                                 <api_version> of some api, e.g. 2023-05-15

                             Or Address can be for vLLM:
                              Use: "vllm:IP:port" for OpenAI-compliant vLLM endpoint
                              Use: "vllm_chat:IP:port" for OpenAI-Chat-compliant vLLM endpoint

                              Use: "vllm:http://IP:port/v1" for OpenAI-compliant vLLM endpoint
                              Use: "vllm_chat:http://IP:port/v1" for OpenAI-Chat-compliant vLLM endpoint

                              Use: "vllm:https://IP/v1" for OpenAI-compliant vLLM endpoint
                              Use: "vllm_chat:https://IP/v1" for OpenAI-Chat-compliant vLLM endpoint

                              For example, for non-standard URL and API key for vllm, one would do:
                                 vllm_chat:https://vllm.h2o.ai:None:/1b1219f7-4bb4-43e9-881f-fa8fa9fe6e04/v1:1234ABCD
                                 where vllm.h2o.ai is the DNS name of the IP, None means no extra port, so will be dropped from base_url when using API, /1b1219f7-4bb4-43e9-881f-fa8fa9fe6e04/v1 is the url of the "page" to access, and 1234ABCD is the api key
                              Or for example:
                                 vllm_chat:https://vllm.h2o.ai:5001:/1b1219f7-4bb4-43e9-881f-fa8fa9fe6e04/v1:1234ABCD
                                 where vllm.h2o.ai is the DNS name of the IP, 5001 is the port, /1b1219f7-4bb4-43e9-881f-fa8fa9fe6e04/v1 is the url of the "page" to access, and 1234ABCD is the api key

                              Or for groq, can use OpenAI API like:
                               GROQ IS BROKEN FOR OPENAI API:
                                   vllm:https://api.groq.com/openai:None:/v1:<api key>'
                                   with: other model_lock or CLI options: {'inference_server': 'vllm:https://api.groq.com/openai:None:/v1:<api key>', 'base_model':'mixtral-8x7b-32768', 'visible_models':'mixtral-8x7b-32768', 'max_seq_len': 31744, 'prompt_type':'plain'}
                                   i.e.ensure to use 'plain' prompt, not mixtral.
                              For groq:
                                 groq and ensures set env GROQ_API_KEY
                                 or groq:<api key>
                                 with: other model_lock or CLI options: {'inference_server': 'groq:<api key>', 'base_model':'mixtral-8x7b-32768', 'visible_models':'mixtral-8x7b-32768', 'max_seq_len': 31744, 'prompt_type':'plain'}

                             Or Address can be replicate:
                             Use:
                              --inference_server=replicate:<model name string> will use a Replicate server, requiring a Replicate key.
                              e.g. <model name string> looks like "a16z-infra/llama13b-v2-chat:df7690f1994d94e96ad9d568eac121aecf50684a0b0963b25a41cc40061269e5"

                             Or Address can be for AWS SageMaker:
                              Use: "sagemaker_chat:<endpoint name>" for chat models that AWS sets up as dialog
                              Use: "sagemaker:<endpoint name>" for foundation models that AWS only text as inputs

                             Or Address can be for Anthropic Claude.  Ensure key is set in env ANTHROPIC_API_KEY
                              Use: "anthropic
                              E.g. --base_model=claude-2.1 --inference_server=anthropic

                             Or Address can be for Google Gemini.  Ensure key is set in env GOOGLE_API_KEY
                              Use: "google"
                              E.g. --base_model=gemini-pro --inference_server=google

                             Or Address can be for MistralAI.  Ensure key is set in env MISTRAL_API_KEY
                              Use: "mistralai"
                              E.g. --base_model=mistral-medium --inference_server=mistralai

    :param regenerate_clients: Whether to regenerate client every LLM call or use start-up version
           Benefit of doing each LLM call is timeout can be controlled to max_time in expert settings, else we use default of 600s.
           Maybe risky, some lack of thread safety: https://github.com/encode/httpx/discussions/3043, so disabled
           Because gradio clients take long time to start-up, we don't ever regenerate them each time (including llava models)
    :param regenerate_gradio_clients: Whether to also regenerate gradio clients (slow)

    :param prompt_type: type of prompt, usually matched to fine-tuned model or plain for foundational model
    :param prompt_dict: If prompt_type=custom, then expects (some) items returned by get_prompt(..., return_dict=True)
    :param system_prompt: Universal system prompt to use if model supports, like LLaMa2, regardless of prompt_type definition.
           Useful for langchain case to control behavior, or OpenAI and Replicate.
           If None, 'None', or 'auto', then for LLaMa or other models that internally have system_prompt, will use default for each model
           If '', then no system prompt (no empty template given to model either, just no system part added at all)
           If some string not in ['None', 'auto'], then use that as system prompt
           Default is '', no system_prompt, because often it hurts performance/accuracy
    :param allow_chat_system_prompt:
           Whether to use conversation_history to pre-append system prompt

    :param llamacpp_path: Location to store downloaded gguf or load list of models from
           Note HF models go into hf cache folder, and gpt4all models go into their own cache folder
           Can override with ENV LLAMACPP_PATH
    :param llamacpp_dict:
           n_gpu_layers: for llama.cpp based models, number of GPU layers to offload (default is all by using large value)
           use_mlock: when using `llama.cpp` based CPU models, for computers with low system RAM or slow CPUs, recommended False
           n_batch: Can make smaller to 128 for slower low-memory CPU systems
           n_gqa: Required to be 8 for LLaMa 70B
           ... etc. anything that could be passed to llama.cpp or GPT4All models
           e.g. python generate.py --base_model='llama' --prompt_type=llama2 --score_model=None --langchain_mode='UserData' --user_path=user_path --llamacpp_dict="{'n_gpu_layers':25,'n_batch':128}"
    :param model_path_llama: model path or URL (for auto-download)
    :param model_name_gptj: model path or URL (for auto-download)
    :param model_name_gpt4all_llama: model path or URL (for auto-download)
    :param model_name_exllama_if_no_config: exllama model's full path for model, tokenizer, generator for use when no HuggingFace config
    :param exllama_dict for setting various things for Exllama class
           E.g. compress_pos_emb,
                set_auto_map,
                gpu_peer_fix,
                alpha_value,
                matmul_recons_thd,
                fused_mlp_thd
                sdp_thd
                fused_attn
                matmul_fused_remap
                rmsnorm_no_half2
                rope_no_half2
                matmul_no_half2
                silu_no_half2
                concurrent_streams
           E.g. to set memory to be split across 2 GPUs, use --exllama_dict="{'set_auto_map':20,20}"
    :param gptq_dict: Choices for AutoGPTQ, e.g. one can change defaults to these non-defaults:
         inject_fused_attention=False
         disable_exllama=True
         use_triton=True
    :param attention_sinks: Whether to enable attention sinks.
    :param sink_dict: dict of options for attention sinks
           E.g. {'window_length': 1024, 'num_sink_tokens': 4}
           Default is window length same size as max_input_tokens (max_seq_len if max_input_tokens not set)
    :param hf_model_dict: dict of options for HF models using transformers

    :param truncation_generation: Whether (for torch) to terminate generation once reach context length of model.
            For some models, perplexity becomes critically large beyond context
            For other models like Mistral, one can generate beyond max_seq_len set to 4096 or 8192 without issue, since based upon 32k embeddings
            codellama can also generate beyond its 16k context length
            So default is off, but for simpler/older models True may be wise to avoid bad generations

    :param model_lock: Lock models to specific combinations, for ease of use and extending to many models
           Only used if gradio = True
           List of dicts, each dict has base_model, tokenizer_base_model, lora_weights, inference_server, prompt_type, and prompt_dict
           If all models have same prompt_type, and prompt_dict, can still specify that once in CLI outside model_lock as default for dict
           Can specify model_lock instead of those items on CLI
           As with CLI itself, base_model can infer prompt_type and prompt_dict if in prompter.py.
             Also, tokenizer_base_model and lora_weights are optional.
             Also, inference_server is optional if loading model from local system.
           All models provided will automatically appear in compare model mode
           Model loading-unloading and related choices will be disabled.  Model/lora/server adding will be disabled
    :param model_lock_columns: How many columns to show if locking models (and so showing all at once)
           If None, then defaults to up to 3
           if -1, then all goes into 1 row
           Maximum value is 4 due to non-dynamic gradio rendering elements
    :param model_lock_layout_based_upon_initial_visible: Whether to base any layout upon visible models (True)
           or upon all possible models.  gradio does not allow dynamic objects, so all layouts are preset,
           and these are two reasonable options.
           False is best when there are many models and user excludes middle ones as being visible.
    :param fail_if_cannot_connect: if doing model locking (e.g. with many models), fail if True.  Otherwise ignore.
           Useful when many endpoints and want to just see what works, but still have to wait for timeout.

    :param temperature: generation temperature
    :param top_p: generation top_p
    :param top_k: generation top_k
    :param penalty_alpha: penalty_alpha>0 and top_k>1 enables contrastive search (not all models support)
    :param num_beams: generation number of beams
    :param repetition_penalty: generation repetition penalty
    :param num_return_sequences: generation number of sequences (1 forced for chat)
    :param do_sample: generation sample.  Enable for sampling for given temperature, top_p, top_k, else greedy decoding and then temperature, top_p, top_k not used.
        https://huggingface.co/docs/transformers/main_classes/text_generation#transformers.GenerationConfig.do_sample
        https://txt.cohere.com/llm-parameters-best-outputs-language-ai/
        https://medium.com/@daniel.puenteviejo/the-science-of-control-how-temperature-top-p-and-top-k-shape-large-language-models-853cb0480dae
    :param seed: seed (0 means random seed, >0 uses that seed for sampling so reproducible even for sampling).  None becomes 0.
    :param max_new_tokens: generation max new tokens
    :param min_new_tokens: generation min tokens
    :param early_stopping: generation early stopping
    :param max_time: maximum time to allow for generation
    :param memory_restriction_level: 0 = no restriction to tokens or model, 1 = some restrictions on token 2 = HF like restriction 3 = very low memory case
    :param debug: enable debug mode
    :param save_dir: directory chat data is saved to
    :param local_files_only: whether to only use local files instead of doing to HF for models
    :param resume_download: whether to resume downloads from HF for models
    :param use_auth_token: whether to use HF auth token (requires CLI did huggingface-cli login before)
    :param trust_remote_code: whether to use trust any code needed for HF model
    :param rope_scaling:
           For HF transformers model: scaling for rope-based models.
           For long context models that have been tuned for a specific size, you have to only use that specific size by setting the `--rope_scaling` exactly correctly
            e.g. --rope_scaling="{'type':'dynamic', 'factor':4}"
            e.g. --rope_scaling="{'type':'linear', 'factor':4}"
            e.g. python generate.py --rope_scaling="{'type':'linear','factor':4}" --base_model=lmsys/vicuna-13b-v1.5-16k --hf_embedding_model=sentence-transformers/all-MiniLM-L6-v2 --load_8bit=True --langchain_mode=UserData --user_path=user_path --prompt_type=vicuna11 --h2ocolors=False
           For exllama model: --rope_scaling="{'alpha_value':4}" .  This automatically scales max_seq_len for exllama
    :param max_seq_len: Manually set maximum sequence length for the LLM
    :param max_output_seq_len: Manually set maximum output length for the LLM
    :param offload_folder: path for spilling model onto disk
    :param src_lang: source languages to include if doing translation (None = all)
    :param tgt_lang: target languages to include if doing translation (None = all)

    :param prepare_offline_level:
           Whether to just prepare for offline use, do not go into cli, eval, or gradio run modes
           0 : no prep
           1: prepare just h2oGPT with exact same setup as passed to CLI and ensure all artifacts for h2oGPT alone added to ~/.cache/
           2: prepare h2oGPT + all inference servers so h2oGPT+inference servers can use the ~/.cache/
    :param cli: whether to use CLI (non-gradio) interface.
    :param cli_loop: whether to loop for CLI (False usually only for testing)
    :param gradio: whether to enable gradio, or to enable benchmark mode
    :param openai_server: whether to launch OpenAI proxy server for local gradio server
           Disabled if API is disabled or --auth=closed
    :param openai_port: port for OpenAI proxy server
    :param gradio_offline_level: > 0, then change fonts so full offline
           == 1 means backend won't need internet for fonts, but front-end UI might if font not cached
           == 2 means backend and frontend don't need internet to download any fonts.
           Note: Some things always disabled include HF telemetry, gradio telemetry, chromadb posthog that involve uploading.
           This option further disables google fonts for downloading, which is less intrusive than uploading,
           but still required in air-gapped case.  The fonts don't look as nice as google fonts, but ensure full offline behavior.
           Also set --share=False to avoid sharing a gradio live link.
    :param server_name: IP to use.  In linux 0.0.0.0 is good choice so exposed to outside host, else for only local use 127.0.0.1.
                        For windows/MAC 0.0.0.0 or 127.0.0.1 will work, but may need to specify actual LAN IP address for other LAN clients to see.
    :param share: whether to share the gradio app with sharable URL
    :param open_browser: whether to automatically open browser tab with gradio UI
    :param close_button: Whether to show close button in system tab (if not public)
    :param shutdown_via_api: Whether to allow shutdown via API
    :param root_path: The root path (or "mount point") of the application,
           if it's not served from the root ("/") of the domain. Often used when the application is behind a reverse proxy
           that forwards requests to the application. For example, if the application is served at "https://example.com/myapp",
           the `root_path` should be set to "/myapp".
    :param ssl_verify: passed go gradio launch
    :param ssl_keyfile: passed go gradio launch
    :param ssl_certfile: passed go gradio launch
    :param ssl_keyfile_password: passed go gradio launch

    :param chat: whether to enable chat mode with chat history
    :param chat_conversation: list of tuples of (human, bot) conversation pre-appended to existing chat when using instruct/chat models
           Requires also add_chat_history_to_context = True
           It does *not* require chat=True, so works with nochat_api etc.
    :param text_context_list: List of strings to add to context for non-database version of document Q/A for faster handling via API etc.
           Forces LangChain code path and uses as many entries in list as possible given max_seq_len, with first assumed to be most relevant and to go near prompt.
    :param stream_output: whether to stream output
    :param async_output: Whether to do asyncio handling
           For summarization
           Applicable to HF TGI server
           Only if stream_output=False in CLI, UI, or API
    :param num_async: Number of simultaneously allowed asyncio calls to make for async_output
           Too many will overload inference server, too few will be too slow
    :param show_examples: whether to show clickable examples in gradio
    :param verbose: whether to show verbose prints
    :param h2ocolors: whether to use H2O.ai theme
    :param dark: whether to use dark mode for UI by default (still controlled in UI)
    :param height: height of chat window
    :param render_markdown: Whether to render markdown in chatbot UI.  In some cases this distorts the rendering.
           https://github.com/gradio-app/gradio/issues/4344#issuecomment-1771963021
    :param show_lora: whether to show LORA options in UI (expert so can be hard to understand)
    :param show_llama: whether to show LLaMa.cpp/GPT4All options in UI (only likely useful if have weak GPUs)
    :param show_gpt4all: whether to show GPT4All models in UI (not often useful, llama.cpp models best)
    :param login_mode_if_model0: set to True to load --base_model after client logs in, to be able to free GPU memory when model is swapped
    :param block_gradio_exit: whether to block gradio exit (used for testing)
    :param concurrency_count: gradio concurrency count (1 is optimal for local LLMs to avoid sharing cache that messes up models, else 64 is used if hosting remote inference servers only)
    :param api_open: If False, don't let API calls skip gradio queue
    :param allow_api: whether to allow API calls at all to gradio server
    :param input_lines: how many input lines to show for chat box (>1 forces shift-enter for submit, else enter is submit)
    :param gradio_size: Overall size of text and spaces: "xsmall", "small", "medium", "large".
           Small useful for many chatbots in model_lock mode
    :param show_copy_button: Whether to show copy button for chatbots
    :param large_file_count_mode: Whether to force manual update to UI of drop-downs, good idea if millions of chunks or documents
    :param gradio_ui_stream_chunk_size: Number of characters to wait before pushing text to ui.
           None is default, which is 0 when not doing model lock.  Else 20 by default.
           20 is reasonable value for fast models and fast systems when handling several models at once
           Choose 0 to disable (this disables use of gradio_ui_stream_chunk_min_seconds and gradio_ui_stream_chunk_seconds too)
           Work around for these bugs that lead to UI being overwhelmed under various cases
           https://github.com/gradio-app/gradio/issues/5914
           https://github.com/gradio-app/gradio/issues/6609
    :param gradio_ui_stream_chunk_min_seconds: Number of seconds before allow yield to avoid spamming yields at rate user would not care about, regardless of chunk_size
    :param gradio_ui_stream_chunk_seconds: Number of seconds to yield regardless of reaching gradio_ui_stream_chunk_size as long as something to yield
           Helps case when streaming is slow and want to see progress at least every couple seconds
    :param gradio_api_use_same_stream_limits: Whether to use same streaming limits as UI for API
    :param gradio_upload_to_chatbot: Whether to show upload in chatbots
    :param gradio_upload_to_chatbot_num_max: Max number of things to add to chatbot
    :param gradio_errors_to_chatbot: Whether to show errors in Accordion in chatbot or just in exceptions in each tab

    :param pre_load_embedding_model: Whether to preload embedding model for shared use across DBs and users (multi-thread safe only)
    :param embedding_gpu_id: which GPU to place embedding model on.
                             Only used if preloading embedding model.
                             If 'auto', then use first device as is default
                             If 'cpu' or some other string like 'mps', then use that as device name.

    :param auth: gradio auth for launcher in form [(user1, pass1), (user2, pass2), ...]
                 e.g. --auth=[('jon','password')] with no spaces
                 e.g. --auth="[('jon', 'password)())(')]" so any special characters can be used
                 e.g. --auth=auth.json to specify persisted state file with name auth.json (auth_filename then not required)
                 e.g. --auth='' will use default auth.json as file name for persisted state file (auth_filename good idea to control location)
                 e.g. --auth=None will use no auth, but still keep track of auth state, just not from logins
    :param auth_filename:
         Set auth filename, used only if --auth= was passed list of user/passwords
    :param auth_access:
         'open': Allow new users to be added
         'closed': Stick to existing users
    :param auth_freeze: whether freeze authentication based upon current file, no longer update file
    :param auth_message: Message to show if having users login, fixed if passed, else dynamic internally
    :param google_auth: Whether to use google auth
    :param guest_name: guess name if using auth and have open access.
           If '', then no guest allowed even if open access, then all databases for each user always persisted
    :param enforce_h2ogpt_api_key: Whether to enforce h2oGPT token usage for API
    :param enforce_h2ogpt_ui_key: Whether to enforce h2oGPT token usage for UI (same keys as API assumed)
    :param h2ogpt_api_keys: list of tokens allowed for API access or file accessed on demand for json of list of keys
    :param h2ogpt_key: E.g. can be set when accessing gradio h2oGPT server from local gradio h2oGPT server that acts as client to that inference server
                       Only applied for API at runtime when API accesses using gradio inference_server are made
    :param extra_allowed_paths: List of strings for extra allowed paths users could access for file viewing/downloading.  '.' can be used but be careful what that exposes.
           Note by default all paths in langchain_mode_paths given at startup are allowed
    :param blocked_paths: Any blocked paths to add for gradio access for file viewing/downloading.

    :param max_max_time: Maximum max_time for gradio slider
    :param max_max_new_tokens: Maximum max_new_tokens for gradio slider
    :param min_max_new_tokens: Minimum of max_new_tokens, when auto-scaling down to handle more docs/prompt, but still let generation have some tokens
    :param max_input_tokens: Max input tokens to place into model context for each LLM call
                             -1 means auto, fully fill context for query, and fill by original document chunk for summarization
                             >=0 means use that to limit context filling to that many tokens
    :param max_total_input_tokens: like max_input_tokens but instead of per LLM call, applies across all LLM calls for single summarization/extraction action

    :param docs_token_handling: 'chunk' means fill context with top_k_docs (limited by max_input_tokens or model_max_len) chunks for query
                                                                     or top_k_docs original document chunks summarization
                                None or 'split_or_merge' means same as 'chunk' for query, while for summarization merges documents to fill up to max_input_tokens or model_max_len tokens

    :param docs_joiner: string to join lists of text when doing split_or_merge.  None means '\n\n'

    :param hyde_level: HYDE level for HYDE approach (https://arxiv.org/abs/2212.10496)
                 0: No HYDE
                 1: Use non-document-based LLM response and original query for embedding query
                 2: Use document-based LLM response and original query for embedding query
                 3+: Continue iterations of embedding prior answer and getting new response
    :param hyde_template:
                 None, 'None', 'auto' uses internal value and enable
                 '{query}' is minimal template one can pass
    :param hyde_show_only_final:  Whether to show only last result of HYDE, not intermediate steps
    :param hyde_show_intermediate_in_accordion: Whether to show intermediate HYDE, but inside HTML accordion

    :param visible_models: Which models in model_lock list to show by default
           Takes integers of position in model_lock (model_states) list or strings of base_model names
           Ignored if model_lock not used
           For nochat API, this is single item within a list for model by name or by index in model_lock
                                If None, then just use first model in model_lock list
                                If model_lock not set, use model selected by CLI --base_model etc.
           Note that unlike h2ogpt_key, this visible_models only applies to this running h2oGPT server,
              and the value is not used to access the inference server.
              If need a visible_models for an inference server, then use --model_lock and group together.
    :param max_visible_models: maximum visible models to allow to select in UI

    :param visible_ask_anything_high: Whether ask anything block goes near top or near bottom of UI Chat
    :param visible_visible_models: Whether visible models drop-down is visible in UI
    :param visible_submit_buttons: whether submit buttons are visible when UI first comes up
    :param visible_side_bar: whether left side bar is visible when UI first comes up
    :param visible_doc_track: whether left side bar's document tracking is visible when UI first comes up
    :param visible_chat_tab: "" for chat tab
    :param visible_doc_selection_tab:  "" for doc selection tab
    :param visible_doc_view_tab: "" for doc view tab
    :param visible_chat_history_tab: "" for chat history tab
    :param visible_expert_tab: "" for expert tab
    :param visible_models_tab: "" for models tab
    :param visible_system_tab: "" for system tab
    :param visible_tos_tab: "" for ToS tab
    :param visible_login_tab: "" for Login tab (needed for persistence or to enter key for UI access to models and ingestion)
    :param visible_hosts_tab: "" for hosts tab
    :param chat_tables: Just show Chat as block without tab (useful if want only chat view)
    :param visible_h2ogpt_links: Whether github stars, URL are visible
    :param visible_h2ogpt_qrcode: Whether QR code is visible
    :param visible_h2ogpt_logo: Whether central logo is visible
    :param visible_chatbot_label: Whether to show label in chatbot (e.g. if only one model for own purpose, then can set to False)
    :param visible_all_prompter_models: Whether to show all prompt_type_to_model_name items or just curated ones
    :param visible_curated_models: Whether to show curated models (useful to see few good options)
    :param actions_in_sidebar: Whether to show sidebar with actions in old style
    :param document_choice_in_sidebar: Whether to show document choices in sidebar
           Useful if often changing picking specific document(s)
    :param enable_add_models_to_list_ui: Whether to show add model, lora, server to dropdown list
           Disabled by default since clutters Models tab in UI, and can just add custom item directly in dropdown
    :param max_raw_chunks: Maximum number of chunks to show in UI when asking for raw DB text from documents/collection
    :param pdf_height: Height of PDF viewer in UI
    :param avatars: Whether to show avatars in chatbot
    :param add_disk_models_to_ui: Whether to add HF cache models and llama.cpp models to UI
    :param page_title: Title of the web page, default is h2oGPT
    :param favicon_path: Path to favicon, default is h2oGPT favicon
    :param visible_ratings: Whether full review is visible, else just likable chatbots
    :param reviews_file: File to store reviews, set to `reviews.csv` if visible_ratings=True if this isn't set

    :param sanitize_user_prompt: whether to remove profanity from user input (slows down input processing)
      Requires optional packages:
      pip install alt-profanity-check==1.2.2 better-profanity==0.7.0
    :param sanitize_bot_response: whether to remove profanity and repeat lines from bot output (about 2x slower generation for long streaming cases due to better_profanity being slow)
    :param extra_model_options: extra models to show in list in gradio
    :param extra_lora_options: extra LORA to show in list in gradio
    :param extra_server_options: extra servers to show in list in gradio
    :param score_model: which model to score responses
           None: no response scoring
           'auto': auto mode, '' (no model) for CPU or 1 GPU, 'OpenAssistant/reward-model-deberta-v3-large-v2' for >=2 GPUs,
            because on CPU takes too much compute just for scoring response

    :param verifier_model: model for verifier
    :param verifier_tokenizer_base_model: tokenizer server for verifier (if empty/None, infer from model)
    :param verifier_inference_server: inference server for verifier

    :param eval_filename: json file to use for evaluation, if None is sharegpt
    :param eval_prompts_only_num: for no gradio benchmark, if using eval_filename prompts for eval instead of examples
    :param eval_prompts_only_seed: for no gradio benchmark, seed for eval_filename sampling
    :param eval_as_output: for no gradio benchmark, whether to test eval_filename output itself

    :param langchain_mode: Data source to include.  Choose "UserData" to only consume files from make_db.py.
           None: auto mode, check if langchain package exists, at least do LLM if so, else Disabled
           If not passed, then chosen to be first langchain_modes, else langchain_mode->Disabled is set if no langchain_modes either
           WARNING: wiki_full requires extra data processing via read_wiki_full.py and requires really good workstation to generate db, unless already present.
    :param user_path: user path to glob from to generate db for vector search, for 'UserData' langchain mode.
           If already have db, any new/changed files are added automatically if path set, does not have to be same path used for prior db sources
    :param langchain_modes: dbs to generate at launch to be ready for LLM
           Apart from additional user-defined collections, can include ['wiki', 'wiki_full', 'UserData', 'MyData', 'github h2oGPT', 'DriverlessAI docs']
             But wiki_full is expensive and requires preparation
           To allow personal space only live in session, add 'MyData' to list
           Default: If only want to consume local files, e.g. prepared by make_db.py, only include ['UserData']
           If have own user modes, need to add these here or add in UI.
    :param langchain_mode_paths: dict of langchain_mode keys and disk path values to use for source of documents
           E.g. "{'UserData2': 'userpath2'}"
           A disk path be None, e.g. --langchain_mode_paths="{'UserData2': None}" even if existing DB, to avoid new documents being added from that path, source links that are on disk still work.
           If `--user_path` was passed, that path is used for 'UserData' instead of the value in this dict
    :param langchain_mode_types: dict of langchain_mode keys and database types
           E.g. python generate.py --base_model=llama --langchain_modes=['TestData'] --langchain_mode_types="{'TestData':'shared'}"
           The type is attempted to be inferred if directory already exists, then don't have to pass this
    :param detect_user_path_changes_every_query: whether to detect if any files changed or added every similarity search (by file hashes).
           Expensive for large number of files, so not done by default.  By default only detect changes during db loading.

    :param langchain_action: Mode langchain operations in on documents.
            Query: Make query of document(s)
            Summarize or Summarize_map_reduce: Summarize document(s) via map_reduce
            Summarize_all: Summarize document(s) using entire document at once
            Summarize_refine: Summarize document(s) using entire document, and try to refine before returning summary
            Extract: Extract information from document(s) via map (no reduce)

            Currently enabled is Query, Summarize, and Extract.

            Summarize is a "map reduce" and extraction is "map". That is, map returns a text output (roughly) per input item, while reduce reduces all maps down to single text output.
            The "roughly" refers to fact that if one has docs_token_handling='split_or_merge' then we split or merge chunks, so you will get a map for some optimal-sized chunks given the model size.  If you choose docs_token_handling='chunk', then you get back a map for each chunk you give, but you should ensure the model token limit is not exceeded yourself.

            Summarize is useful when wanting to reduce down to single text, while Extract is useful when want to operate the prompt on blocks of data and get back a result per block.

    :param langchain_agents: Which agents to use
            'search': Use Web Search as context for LLM response, e.g. SERP if have SERPAPI_API_KEY in env
    :param force_langchain_evaluate: Whether to force langchain LLM use even if not doing langchain, mostly for testing.

    :param visible_langchain_actions: Which actions to allow
    :param visible_langchain_agents: Which agents to allow

    :param document_subset: Default document choice when taking subset of collection
    :param document_choice: Chosen document(s) by internal name, 'All' means use all docs
    :param document_source_substrings: substrings in list to search in source names in metadata for chroma dbs
    :param document_source_substrings_op: 'and or 'or' for source search words
    :param document_content_substrings: substrings in list to search in content for chroma dbs
    :param document_content_substrings_op: 'and or 'or' for content search words

    :param use_llm_if_no_docs: Whether to use LLM even if no documents, when langchain_mode=UserData or MyData or custom
    :param load_db_if_exists: Whether to load chroma db if exists or re-generate db
    :param keep_sources_in_context: Whether to keep url sources in context, not helpful usually
    :param db_type: 'faiss' for in-memory
                    'chroma' (for chroma >= 0.4)
                    'chroma_old' (for chroma < 0.4) -- recommended for large collections
                    'weaviate' for persisted on disk
                    'qdrant' for a Qdrant server or an in-memory instance
    :param use_openai_embedding: Whether to use OpenAI embeddings for vector db
    :param use_openai_model: Whether to use OpenAI model for use with vector db
    :param hf_embedding_model: Which HF embedding model to use for vector db
           Default is instructor-large with 768 parameters per embedding if have GPUs, else all-MiniLM-L6-v2 if no GPUs
           Can also choose simpler model with 384 parameters per embedding: "sentence-transformers/all-MiniLM-L6-v2"
           Can also choose even better embedding with 1024 parameters: 'hkunlp/instructor-xl'
           We support automatically changing of embeddings for chroma, with a backup of db made if this is done
    :param migrate_embedding_model: whether to use hf_embedding_model embedding even if database already had an embedding set.
           used to migrate all embeddings to a new one, but will take time to re-embed.
           Default (False) is to use the prior embedding for existing databases, and only use hf_embedding_model for new databases
           If had old database without embedding saved, then hf_embedding_model is also used.
    :param auto_migrate_db: whether to automatically migrate any chroma<0.4 database from duckdb -> sqlite version
    :param cut_distance: Distance to cut off references with larger distances when showing references.
           1.64 is good to avoid dropping references for all-MiniLM-L6-v2, but instructor-large will always show excessive references.
           For all-MiniLM-L6-v2, a value of 1.5 can push out even more references, or a large value of 100 can avoid any loss of references.
    :param answer_with_sources: Whether to determine (and return) sources
    :param append_sources_to_answer: Whether to place source information in chat response (ignored by LLM).  Always disabled for API.
    :param append_sources_to_chat: Whether to place sources information in chat response but in separate chat turn (ignored by LLM).  Always disabled for API.
    :param show_accordions: whether to show accordion for document references in chatbot UI
    :param top_k_docs_max_show: Max number of docs to show in UI for sources
           If web search is enabled, then this is modified to be max(top_k_docs_max_show, number of links used in search)
    :param show_link_in_sources: Whether to show URL link to source document in references
    :param langchain_instruct_mode: Whether to have langchain operate in instruct mode (True) or few-shot mode (False)
           Normally this might be decidable from --prompt_type=plain, but in some cases (like vllm_chat) we want inference server to handle all prompting, so need to tell h2oGPT to use plain prompting, but don't want to change langchain behavior

    :param pre_prompt_query: prompt before documents to query, if None then use internal defaults
    :param prompt_query: prompt after documents to query, if None then use internal defaults
    :param pre_prompt_summary: prompt before documents to summarize/extract from, if None then use internal defaults
    :param prompt_summary: prompt after documents to summarize/extract from, if None then use internal defaults
           For summarize/extract, normal to have empty query (nothing added in ask anything in UI or empty string in API)
           If pass query, template is "Focusing on %s, %s" % (query, prompt_summary)
           If pass query and iinput, template is "Focusing on %s, %s, %s" % (query, iinput, prompt_summary)

    For query, prompt template is:
      "{pre_prompt_query}
        \"\"\"
        {fstring}
        \"\"\"
        {prompt_query}{instruction}"
    For summarization or extraction, for some internal document part fstring, the template looks like:
        "{pre_prompt_summary}
        \"\"\"
        {fstring}
        \"\"\"
        {prompt_summary}"
     If added instruction for summarization or extraction, prompt template is
      "{pre_prompt_summary}
        \"\"\"
        {fstring}
        \"\"\"
        Focusing on {instruction}, {prompt_summary}"
        
    {fstring} is some document chunks separated by {docs_joiner}

    :param hyde_llm_prompt: hyde prompt for first step when using LLM
    :param doc_json_mode: Use system prompting approach with JSON input and output, e.g. for codellama or GPT-4
    :param metadata_in_context: Keys of metadata to include in LLM context for Query
           'all': Include all metadata
           'auto': Includes these keys: ['date', 'file_path', 'input_type', 'keywords', 'chunk_id', 'page', 'source', 'title', 'total_pages']
           ['key1', 'key2', ...]: Include only these keys
            NOTE: not all parsers have all keys, only keys that exist are added to each document chunk.
           Example key-values that some PDF parsers make:
                author = Zane Durante, Bidipta Sarkar, Ran Gong, Rohan Taori, Yusuke Noda, Paul Tang, Ehsan Adeli, Shrinidhi Kowshika Lakshmikanth, Kevin Schulman, Arnold Milstein, Demetri Terzopoulos, Ade Famoti, Noboru Kuno, Ashley Llorens, Hoi Vo, Katsu Ikeuchi, Li Fei-Fei, Jianfeng Gao, Naoki Wake, Qiuyuan Huang
                chunk_id = 21
                creationDate = D:20240209020045Z
                creator = LaTeX with hyperref
                date = 2024-02-11 23:58:11.929155
                doc_hash = 5db1d548-7
                file_path = /tmp/gradio/15ac25af8610f21b9ab55252f1944841727ba157/2402.05929.pdf
                format = PDF 1.5
                hashid = 3cfb31cea127c745c72554f4714105dd
                head = An Interactive Agent Foundation Model
                Figure 2. We
                input_type = .pdf
                keywords = Machine Learning, ICML
                modDate = D:20240209020045Z
                order_id = 2
                page = 2
                parser = PyMuPDFLoader
                producer = pdfTeX-1.40.25
                source = /tmp/gradio/15ac25af8610f21b9ab55252f1944841727ba157/2402.05929.pdf
                subject = Proceedings of the International Conference on Machine Learning 2024
                time = 1707724691.929157
                title = An Interactive Agent Foundation Model
                total_pages = 22

    :param add_chat_history_to_context: Include chat context when performing action
           Not supported when using CLI mode
    :param add_search_to_context: Include web search in context as augmented prompt
    :param context: Default context to use (for system pre-context in gradio UI)
           context comes before chat_conversation and any document Q/A from text_context_list
    :param iinput: Default input for instruction-based prompts
    :param allow_upload_to_user_data: Whether to allow file uploads to update shared vector db (UserData or custom user dbs)
           Ensure pass user_path for the files uploaded to be moved to this location for linking.
    :param reload_langchain_state: Whether to reload langchain_modes.pkl file that contains any new user collections.
    :param allow_upload_to_my_data: Whether to allow file uploads to update personal vector db
    :param enable_url_upload: Whether to allow upload from URL
    :param enable_text_upload: Whether to allow upload of text
    :param enable_sources_list: Whether to allow list (or download for non-shared db) of list of sources for chosen db
    :param chunk: Whether to chunk data (True unless know data is already optimally chunked)
    :param chunk_size: Size of chunks, with typically top-4 passed to LLM, so needs to be in context length
    :param top_k_docs: For langchain_action query: number of chunks to give LLM
                       -1 : auto-fills context up to max_seq_len
                       For langchain_action summarize/extract: number of document parts, like pages for PDF.
                       There's no such thing as chunks for summarization.
                       -1 : auto-fills context up to max_seq_len
    :param docs_ordering_type:
        Type of ordering of docs.
        'best_first': Order by score so score is worst match near prompt
        'best_near_prompt' or 'reverse_sort' : reverse docs order so most relevant is closest to question.
           Best choice for sufficiently smart model, and truncation occurs for oldest context, so best then too.
           But smaller 6_9 models fail to use newest context and can get stuck on old information.
        '' or None (i.e. default) or 'reverse_ucurve_sort' : Sort so most relevant is either near start or near end
           Best to avoid "lost in middle" as well as avoid hallucinating off starting content that LLM focuses on alot.
    :param auto_reduce_chunks: Whether to automatically reduce top_k_docs to fit context given prompt
    :param max_chunks: If top_k_docs=-1, maximum number of chunks to allow
    :param headsize: Maximum number of characters for head of document document for UI to show
    :param n_jobs: Number of processors to use when consuming documents (-1 = all, is default)
    :param n_gpus: Number of GPUs (None = autodetect)
    :param clear_torch_cache_level: 0: never clear except where critically required
                                    1: clear critical
                                    2: clear aggressively and clear periodically every 20s to free-up GPU memory (may lead to lag in response)

    :param use_unstructured: Enable unstructured URL loader
    :param use_playwright: Enable PlayWright URL loader
    :param use_selenium: Enable Selenium URL loader
    :param use_scrapeplaywright: Enable Scrape PlayWright URL loader
    :param use_scrapehttp: Enable Scrape HTTP URL loader using aiohttp

    :param use_pymupdf: enable PyMUPDF 'auto' means use first, use others if they are 'auto' if no result
    :param use_unstructured_pdf: enable Unstructured PDF loader, 'auto' means use if pymupdf fails to get doc result
    :param use_pypdf: enable PyPDF loader 'auto' means use if unstructured fails to get doc result
    :param enable_pdf_ocr: 'auto' means only use OCR if normal text extraction fails.  Useful for pure image-based PDFs with text.
                                  if enable_pdf_doctr == 'on' then don't do.
                            'on' means always do OCR as additional parsing of same documents
                            'off' means don't do OCR (e.g. because it's slow even if 'auto' only would trigger if nothing else worked)
    :param enable_pdf_doctr: Whether to support doctr on pdfs, 'auto' means use do if failed to get doc result so far
    :param try_pdf_as_html: Try "PDF" as if HTML file, in case web link has .pdf extension but really is just HTML

    :param enable_ocr: Whether to support OCR on images
    :param enable_doctr: Whether to support doctr on images (using OCR better than enable_ocr=True)
    :param enable_pix2struct: Whether to support pix2struct on images for captions
    :param enable_captions: Whether to support captions using BLIP for image files as documents,
           then preloads that model if pre_load_image_audio_models=True
    :param enable_llava: If LLaVa IP port is set, whether to use response for image ingestion
    :param enable_transcriptions: Whether to enable audio transcriptions (youtube of from files)
           Preloaded if pre_load_image_audio_models=True

    :param pre_load_image_audio_models: Whether to preload caption model (True), or load after forking parallel doc loader (False)
           parallel loading disabled if preload and have images, to prevent deadlocking on cuda context
           Recommended if using larger caption model or doing production serving with many users to avoid GPU OOM if many would use model at same time
           Also applies to DocTR and ASR models

    :param captions_model: Which model to use for captions.
           captions_model: str = "Salesforce/blip-image-captioning-base",  # continue capable
           captions_model: str = "Salesforce/blip2-flan-t5-xl",   # question/answer capable, 16GB state
           captions_model: str = "Salesforce/blip2-flan-t5-xxl",  # question/answer capable, 60GB state
           Note: opt-based blip2 are not permissive license due to opt and Meta license restrictions
           Disabled for CPU since BLIP requires CUDA
    :param caption_gpu: If support caption, then use GPU if exists
    :param caption_gpu_id: Which GPU id to use, if 'auto' then select 0

    :param doctr_gpu: If support doctr, then use GPU if exists
    :param doctr_gpu_id: Which GPU id to use, if 'auto' then select 0

    :param llava_model:  IP:port for h2oai version of LLaVa gradio server for hosted image chat
           E.g. http://192.168.1.46:7861
           None means no such LLaVa support
    :param llava_prompt: Prompt passed to LLaVa for querying the image

    :param image_file: Initial image for UI (or actual image for CLI) Vision Q/A.  Or list of images for some models
    :param image_control: Initial image for UI Image Control

    :param asr_model: Name of model for ASR, e.g. openai/whisper-medium or openai/whisper-large-v3 or distil-whisper/distil-large-v2 or microsoft/speecht5_asr
           whisper-medium uses about 5GB during processing, while whisper-large-v3 needs about 10GB during processing
    :param asr_gpu: Whether to use GPU for ASR model
    :param asr_gpu_id: Which GPU to put ASR model on (only used if preloading model)
    :param asr_use_better: Whether to use BetterTransformer
    :param asr_use_faster: Whether to use faster_whisper package and models (loads normal whisper then unloads it, to get this into pipeline)

    :param enable_stt: Whether to enable and show Speech-to-Text (STT) with microphone in UI
         Note STT model is always preloaded, but if stt_model=asr_model and pre_load_image_audio_models=True, then asr model is used as STT model.
    :param stt_model: Name of model for STT, can be same as asr_model, which will then use same model for conserving GPU
    :param stt_gpu: Whether to use gpu for STT model
    :param stt_gpu_id: If not using asr_model, then which GPU to go on if using cuda
    :param stt_continue_mode: How to continue speech with button control
           0: Always append audio regardless of start/stop of recording, so always appends in STT model for full STT conversion
              Only can edit after hit stop and then submit, if hit record again edits are lost since using only audio stream for STT conversion
           1: If hit stop, text made so far is saved and audio cleared, so next recording will be separate text conversion
              Can make edits on any text after hitting stop and they are preserved

    :param enable_tts: Whether to enable TTS
    :param tts_gpu: Whether to use GPU if present for TTS
    :param tts_gpu_id: Which GPU ID to use for TTS
    :param tts_model: Which model to use.
                   For microsoft, use 'microsoft/speecht5_tts'
                   For coqui.ai use one given by doing in python:
                   ```python
                   from src.tts_coqui import list_models
                   list_models()
                   ```
                   e.g. 'tts_models/multilingual/multi-dataset/xtts_v2'

                   Note that coqui.ai models are better, but some have non-commercial research license, while microsoft models are MIT.
                   So coqui.ai ones can be used for non-commercial activities only, and one should agree to their license, see: https://coqui.ai/cpml
                   Commercial use of xtts_v2 should be obtained through their product offering at https://coqui.ai/

    :param tts_gan_model: For microsoft model, which gan model to use, e.g. 'microsoft/speecht5_hifigan'
    :param tts_coquiai_deepspeed: For coqui.ai models, whether to use deepspeed for faster inference
    :param tts_coquiai_roles: role dictionary mapping name (key) to wave file (value)
           If None, then just use default from get_role_to_wave_map()

    :param chatbot_role: Default role for coqui models.  If 'None', then don't by default speak when launching h2oGPT for coqui model choice.
    :param speaker: Default speaker for microsoft models  If 'None', then don't by default speak when launching h2oGPT for microsoft model choice.
    :param tts_language: Default language for coqui models
    :param tts_speed: Default speed of TTS, < 1.0 (needs rubberband) for slower than normal, > 1.0 for faster.  Tries to keep fixed pitch.
    :param tts_action_phrases: Phrases or words to use as action word to trigger click of Submit hands-free assistant style
           Set to None or empty list to avoid any special action words
    :param tts_stop_phrases:  Like tts_action_phrases but to stop h2oGPT from speaking and generating

            NOTE: Action/Stop phrases should be rare but easy (phonetic) words for Whisper to recognize.
                  E.g. asking GPT-4 a couple good ones are ['Nimbus'] and ['Yonder'],
                  and one can help Whisper by saying "Nimbus Clouds" which still works as "stop word" as trigger.

    :param sst_floor: Floor in wave square amplitude below which ignores the chunk of audio
                      This helps avoid long silence messing up the transcription.

    :param jq_schema: control json loader
           By default '.[]' ingests everything in brute-force way, but better to match your schema
           See: https://python.langchain.com/docs/modules/data_connection/document_loaders/json#using-jsonloader

    :param extract_frames: How many unique frames to extract from video (if 0, then just do audio if audio type file as well)

    :param enable_image: Whether to enable image generation model
    :param visible_image_models: Which image gen models to include
    :param image_gpu_ids: GPU ids to use for each visible image model

    :param enable_llava_chat: Whether to use LLaVa model to chat directly against instead of just for ingestion

    :param max_quality: Choose maximum quality ingestion with all available parsers
           Pro: Catches document when some default parsers would fail
           Pro: Enables DocTR that has much better OCR than Tesseract
           Con: Fills DB with results from all parsers, so similarity search gives redundant results

    :param enable_heap_analytics: Toggle telemetry.
    :param heap_app_id: App ID for Heap, change to your ID.
    :return:
    """


